<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ­£å¤šé‚Šå½¢å¤–è§’äº’å‹•æ•™å­¸</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Microsoft JhengHei', sans-serif;
            background-color: #f0f9ff;
        }
        canvas {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .btn {
            transition: all 0.2s;
        }
        .btn:hover {
            transform: translateY(-2px);
        }
        .btn.active {
            background-color: #0ea5e9; /* sky-500 */
            color: white;
            border-color: #0ea5e9;
        }

        /* Scratch Block Styles */
        .scratch-block {
            padding: 8px 12px;
            border-radius: 4px;
            color: white;
            font-weight: bold;
            font-family: system-ui, -apple-system, sans-serif;
            font-size: 14px;
            display: inline-flex;
            align-items: center;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
            margin-bottom: 2px;
            border: 1px solid rgba(0,0,0,0.1);
            position: relative;
            cursor: default;
        }
        .scratch-event { background-color: #FFBF00; border-color: #cc9900; border-radius: 12px 12px 4px 4px; margin-top: 10px; }
        .scratch-pen { background-color: #0FBD8C; border-color: #0b8e69; }
        .scratch-motion { background-color: #4C97FF; border-color: #3373cc; }
        .scratch-control { background-color: #FFAB19; border-color: #cf8b17; display: flex; flex-direction: column; align-items: flex-start; padding: 0; border-radius: 4px;}
        .scratch-myblock { background-color: #FF6680; border-color: #D94D61; }

        .control-header { padding: 8px 12px; width: 100%; display: flex; align-items: center;}
        .control-body { 
            border-left: 12px solid #FFAB19; 
            padding: 4px 4px 4px 8px; 
            background: rgba(0,0,0,0.05);
            width: 100%;
            box-sizing: border-box;
            min-height: 24px;
        }
        .control-footer { 
            height: 12px; 
            width: 100%; 
            background-color: #FFAB19; 
            border-top: 1px solid rgba(0,0,0,0.1);
            border-radius: 0 0 4px 4px;
        }

        .input-oval {
            background-color: white;
            color: #333;
            border-radius: 10px;
            padding: 2px 8px;
            margin: 0 4px;
            min-width: 20px;
            text-align: center;
            font-weight: normal;
        }
        
        /* Dashed Separator */
        .separator {
            border-top: 2px dashed #cbd5e1;
            margin: 40px 0;
            position: relative;
        }
        .separator::after {
            content: 'é€²éšæŒ‘æˆ°';
            position: absolute;
            top: -14px;
            left: 50%;
            transform: translateX(-50%);
            background: #f0f9ff;
            padding: 0 20px;
            color: #64748b;
            font-weight: bold;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center py-8 px-4">

    <!-- Header -->
    <header class="text-center mb-6">
        <h1 class="text-3xl font-bold text-slate-800 mb-2">å¤šé‚Šå½¢å¤–è§’å¯¦é©—å®¤</h1>
        <p class="text-slate-600">é¸æ“‡å½¢ç‹€ï¼Œè§€å¯Ÿå¤–è§’èˆ‡ç¨‹å¼ç©æœ¨çš„é—œä¿‚</p>
    </header>

    <!-- Main Container (Single Shape) -->
    <main class="w-full max-w-4xl bg-white rounded-2xl shadow-xl overflow-hidden mb-8">
        
        <!-- Controls -->
        <div class="bg-slate-50 p-4 border-b border-slate-200 flex flex-wrap justify-center items-center gap-3" id="controls">
            <!-- Preset Buttons generated by JS -->
            <!-- Custom Input Area -->
            <div class="flex items-center gap-2 ml-2 pl-4 border-l-2 border-slate-200">
                <span class="text-sm text-slate-500 font-bold">è‡ªè¨‚:</span>
                <input type="number" id="customInput" min="3" max="50" placeholder="n" 
                       class="w-16 px-2 py-1 rounded border border-slate-300 text-center focus:outline-none focus:border-sky-500 transition-colors">
                <button id="customBtn" class="bg-slate-600 text-white px-3 py-1 rounded hover:bg-slate-700 transition-colors text-sm">
                    ç¹ªè£½
                </button>
            </div>
        </div>

        <!-- Canvas Area -->
        <div class="relative w-full aspect-[4/3] md:aspect-[16/9] bg-slate-100 flex justify-center items-center p-4">
            <canvas id="mainCanvas"></canvas>
            
            <div class="absolute top-6 right-6 flex gap-2">
                <button id="replayBtn" onclick="animateDrawing()" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-lg shadow-lg flex items-center gap-2 font-bold transition-transform active:scale-95">
                    <span>â–¶ åŸ·è¡Œç¨‹å¼</span>
                </button>
            </div>
        </div>

        <!-- Info Panel Grid -->
        <div class="grid grid-cols-1 md:grid-cols-2 border-t border-slate-200">
            <!-- Left: Math Logic -->
            <div class="p-6 border-b md:border-b-0 md:border-r border-slate-200">
                <h2 class="text-xl font-bold text-slate-700 mb-4 flex items-center gap-2">
                    <span>ğŸ“</span> æ•¸å­¸åŸç†
                </h2>
                <div class="mb-6">
                    <h2 id="shapeTitle" class="text-2xl font-bold text-sky-600 mb-1">æ­£ä¸‰è§’å½¢</h2>
                    <p class="text-slate-500 text-sm">é‚Šæ•¸ (n) = <span id="sideCount">3</span></p>
                </div>
                <div class="bg-sky-50 px-6 py-4 rounded-lg border border-sky-100 mb-4">
                    <p class="text-sm text-slate-500 mb-2">å–®ä¸€å¤–è§’è¨ˆç®—å…¬å¼</p>
                    <div class="text-xl font-mono text-slate-800 font-bold">
                        360Â° Ã· <span id="formulaN">3</span> = <span id="formulaResult" class="text-orange-500">120Â°</span>
                    </div>
                </div>
                <div class="p-4 bg-orange-50 rounded-lg border border-orange-100 text-sm text-orange-800 leading-relaxed">
                    <strong>ğŸ’¡ è§€å¿µé€£çµï¼š</strong><br>
                    å¤–è§’å°±æ˜¯ç¨‹å¼ä¸­çš„ã€Œè½‰å½è§’åº¦ã€ã€‚<br>
                    å› ç‚ºè§’è‰²èµ°ä¸€åœˆå›åˆ°åŸé»æ˜¯è½‰äº† 360 åº¦ï¼Œæ‰€ä»¥æ¯æ¬¡è½‰å½çš„è§’åº¦å°±æ˜¯ 360 é™¤ä»¥é‚Šæ•¸ã€‚
                </div>
            </div>

            <!-- Right: Scratch Code -->
            <div class="p-6 bg-slate-50">
                <h2 class="text-xl font-bold text-slate-700 mb-4 flex items-center gap-2">
                    <span>ğŸ±</span> Scratch ç¨‹å¼ç©æœ¨
                </h2>
                <div class="flex flex-col items-start select-none transform scale-90 origin-top-left md:scale-100">
                    <div class="scratch-block scratch-event">ç•¶ <span class="mx-1">ğŸ</span> è¢«é»æ“Š</div>
                    <div class="scratch-block scratch-pen">ç­†è·¡å…¨éƒ¨æ¸…é™¤</div>
                    <div class="scratch-block scratch-pen">ä¸‹ç­†</div>
                    <div class="scratch-block scratch-control w-full max-w-[250px]">
                        <div class="control-header">é‡è¤‡ <span class="input-oval" id="scratchRepeat">3</span> æ¬¡</div>
                        <div class="control-body flex flex-col gap-1">
                            <div class="scratch-block scratch-motion">ç§»å‹• <span class="input-oval">100</span> é»</div>
                            <div class="scratch-block scratch-motion" id="blockTurn">
                                å³è½‰ <svg class="w-4 h-4 mx-1 inline" viewBox="0 0 24 24" fill="white"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm-7 8c0-1.65.52-3.17 1.41-4.42l-1.47-1.48C3.8 8.01 3 9.93 3 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3c-3.31 0-6-2.69-6-6z" transform="scale(-1, 1) translate(-24, 0)"/></svg> <span class="input-oval" id="scratchDegree">120</span> åº¦
                            </div>
                        </div>
                        <div class="control-footer"></div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- SECTION 2: Pattern Lab -->
    <div class="w-full max-w-4xl separator"></div>

    <section class="w-full max-w-4xl bg-white rounded-2xl shadow-xl overflow-hidden mb-12">
        <div class="bg-indigo-50 p-6 border-b border-indigo-100">
            <h2 class="text-2xl font-bold text-indigo-800 flex items-center gap-2">
                <span>ğŸŒ¸</span> é€²éšæŒ‘æˆ°ï¼šå¹¾ä½•åœ–ç´‹å¯¦é©—å®¤
            </h2>
            <p class="text-indigo-600 mt-2">
                è©¦è©¦çœ‹ï¼ä½¿ç”¨ä¸Šæ–¹é¸å®šçš„ <strong id="patternShapeName" class="bg-white px-2 py-0.5 rounded border border-indigo-200">æ­£ä¸‰è§’å½¢</strong>ï¼Œ
                é‡è¤‡ 12 æ¬¡æ—‹è½‰ï¼Œæœƒç•«å‡ºä»€éº¼åœ–æ¡ˆï¼Ÿ
            </p>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2">
            <!-- Left: Complex Scratch Code -->
            <div class="p-6 bg-slate-50 border-r border-slate-200 flex flex-col justify-center">
                <div class="mb-4 text-sm text-slate-500 font-bold">å·¢ç‹€è¿´åœˆç¨‹å¼ç¢¼ (Nested Loop)</div>
                
                <div class="transform scale-90 md:scale-100 origin-top-left">
                    <div class="scratch-block scratch-event">ç•¶ <span class="mx-1">ğŸ</span> è¢«é»æ“Š</div>
                    <div class="scratch-block scratch-pen">ç­†è·¡å…¨éƒ¨æ¸…é™¤</div>
                    
                    <!-- Outer Loop -->
                    <div class="scratch-block scratch-control">
                        <div class="control-header">
                            é‡è¤‡ <span class="input-oval">12</span> æ¬¡ (ä¸€åœˆ)
                        </div>
                        <div class="control-body flex flex-col gap-1">
                            <!-- Draw Shape Function Call -->
                            <div class="scratch-block scratch-myblock">
                                ç•«ä¸€å€‹å¤šé‚Šå½¢
                            </div>
                            
                            <!-- Turn for pattern -->
                            <div class="scratch-block scratch-motion">
                                å³è½‰ <svg class="w-4 h-4 mx-1 inline" viewBox="0 0 24 24" fill="white"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm-7 8c0-1.65.52-3.17 1.41-4.42l-1.47-1.48C3.8 8.01 3 9.93 3 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3c-3.31 0-6-2.69-6-6z" transform="scale(-1, 1) translate(-24, 0)"/></svg> 
                                <span class="input-oval">30</span> åº¦
                            </div>
                        </div>
                        <div class="control-footer"></div>
                    </div>

                    <!-- Comment Bubble -->
                    <div class="mt-4 bg-yellow-100 border border-yellow-300 p-3 rounded-lg text-xs text-yellow-800 relative">
                        <div class="absolute -top-2 left-4 w-4 h-4 bg-yellow-100 border-t border-l border-yellow-300 transform rotate-45"></div>
                        <strong>ç‚ºä»€éº¼æ˜¯ 30 åº¦ï¼Ÿ</strong><br>
                        å› ç‚ºæˆ‘å€‘è¦ç¹ä¸€æ•´åœˆ (360åº¦)ï¼Œ<br>
                        ç¸½å…±ç•« 12 å€‹åœ–å½¢ï¼Œ<br>
                        æ‰€ä»¥ 360 Ã· 12 = 30 åº¦ï¼
                    </div>
                </div>

                <button id="runPatternBtn" onclick="animatePattern()" class="mt-8 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-xl shadow-lg transition-all active:scale-95 flex justify-center items-center gap-2">
                    <span>âœ¨ é–‹å§‹ç¹ªè£½èŠ±æœµ</span>
                </button>
            </div>

            <!-- Right: Pattern Canvas -->
            <div class="bg-white p-4 flex justify-center items-center bg-slate-100">
                <canvas id="patternCanvas" class="bg-white rounded-xl shadow-inner"></canvas>
            </div>
        </div>
    </section>

    <script>
        // --- å…±ç”¨è¨­å®š ---
        const dpr = window.devicePixelRatio || 1;
        
        // --- ä¸»ç•«å¸ƒ (Canvas 1) ---
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        
        // --- èŠ±æœµç•«å¸ƒ (Canvas 2) ---
        const pCanvas = document.getElementById('patternCanvas');
        const pCtx = pCanvas.getContext('2d');

        // é è¨­æŒ‰éˆ•åˆ—è¡¨
        const presets = [
            { sides: 3, name: "æ­£ä¸‰è§’å½¢" },
            { sides: 4, name: "æ­£æ–¹å½¢" },
            { sides: 5, name: "æ­£äº”é‚Šå½¢" },
            { sides: 6, name: "æ­£å…­é‚Šå½¢" },
            { sides: 12, name: "æ­£åäºŒé‚Šå½¢" }
        ];

        let currentSides = 3;
        let rotationOffset = -Math.PI / 2; 
        let isAnimating = false; 
        let isPatternAnimating = false;

        // --- åˆå§‹åŒ–æ§åˆ¶æŒ‰éˆ• ---
        const controlsDiv = document.getElementById('controls');
        const customArea = controlsDiv.querySelector('.border-l-2');

        presets.forEach(shape => {
            const btn = document.createElement('button');
            btn.className = `btn px-3 py-1 md:px-4 md:py-2 rounded-full border border-slate-300 text-slate-600 font-medium hover:bg-white hover:border-sky-400 bg-white text-sm md:text-base ${shape.sides === 3 ? 'active' : ''}`;
            btn.textContent = shape.name;
            btn.dataset.sides = shape.sides; 
            btn.onclick = () => handleShapeChange(shape.sides);
            controlsDiv.insertBefore(btn, customArea);
        });

        const customInput = document.getElementById('customInput');
        const customBtn = document.getElementById('customBtn');

        function handleCustomInput() {
            const val = parseInt(customInput.value);
            if (isNaN(val) || val < 3) {
                alert("é‚Šæ•¸å¿…é ˆå¤§æ–¼ç­‰æ–¼ 3");
                return;
            }
            if (val > 100) alert("ç‚ºäº†é¡¯ç¤ºæ•ˆèƒ½ï¼Œå»ºè­°é‚Šæ•¸å°æ–¼ 100");
            handleShapeChange(val);
        }

        customBtn.onclick = handleCustomInput;
        customInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleCustomInput();
        });

        function handleShapeChange(sides) {
            isAnimating = false;
            isPatternAnimating = false; // åˆ‡æ›åœ–å½¢æ™‚åœæ­¢èŠ±æœµå‹•ç•«

            currentSides = sides;
            
            document.querySelectorAll('.btn').forEach(b => {
                b.classList.remove('active');
                if (parseInt(b.dataset.sides) === sides) {
                    b.classList.add('active');
                }
            });

            customInput.value = sides;
            updateInfoPanel();
            draw(); 
            
            // é‡ç½®èŠ±æœµç•«å¸ƒ
            resizePatternCanvas(); // é€™æœƒè§¸ç™¼ clear
            drawStaticPatternPlaceholder(); // ç•«ä¸€å€‹æ·¡çš„é è¦½æˆ–ä¿æŒç©ºç™½
        }

        function getShapeName(n) {
            const found = presets.find(p => p.sides === n);
            if (found) return found.name;
            return `æ­£${n}é‚Šå½¢`;
        }

        function updateInfoPanel() {
            const angle = 360 / currentSides;
            const name = getShapeName(currentSides);
            
            document.getElementById('shapeTitle').textContent = name;
            document.getElementById('sideCount').textContent = currentSides;
            document.getElementById('formulaN').textContent = currentSides;
            
            const displayAngle = Number.isInteger(angle) ? angle : angle.toFixed(2);
            document.getElementById('formulaResult').textContent = displayAngle + "Â°";

            document.getElementById('scratchRepeat').textContent = currentSides;
            document.getElementById('scratchDegree').textContent = displayAngle;
            
            // æ›´æ–°èŠ±æœµå€å¡Šçš„æ–‡å­—
            document.getElementById('patternShapeName').textContent = name;
            // Removed: document.getElementById('patternBlockName').textContent = name.replace("æ­£", "");
        }

        function resizeCanvas() {
            const parent = canvas.parentElement;
            const rect = parent.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;
            ctx.scale(dpr, dpr);
            if (!isAnimating) draw();
        }

        function resizePatternCanvas() {
            const parent = pCanvas.parentElement;
            const rect = parent.getBoundingClientRect();
            // ä¿æŒæ­£æ–¹å½¢æ¯”ä¾‹æ¯”è¼ƒå¥½çœ‹
            const size = Math.min(rect.width, rect.width); // æ‰‹æ©Ÿç‰ˆé«˜åº¦å¯èƒ½æœ‰é™
            
            pCanvas.width = rect.width * dpr;
            pCanvas.height = rect.width * 0.8 * dpr; // ç¨å¾®æ‰ä¸€é»æˆ–æ˜¯æ­£æ–¹å½¢
            if (window.innerWidth < 768) {
                pCanvas.height = rect.width * dpr; // æ‰‹æ©Ÿç‰ˆæ­£æ–¹å½¢
            }

            pCanvas.style.width = `${rect.width}px`;
            pCanvas.style.height = `${pCanvas.height / dpr}px`;
            
            pCtx.scale(dpr, dpr);
            
            // ç•«å€‹æ·¡ç°è‰²çš„æ ¼ç·šæˆ–ä¸­å¿ƒé»
            const w = pCanvas.width / dpr;
            const h = pCanvas.height / dpr;
            pCtx.clearRect(0,0,w,h);
            pCtx.beginPath();
            pCtx.arc(w/2, h/2, 3, 0, Math.PI*2);
            pCtx.fillStyle = '#ddd';
            pCtx.fill();
        }

        // --- ç¹ªåœ–æ ¸å¿ƒ (Canvas 1) ---
        function getCanvasMetrics() {
            const w = canvas.width / dpr;
            const h = canvas.height / dpr;
            const cx = w / 2;
            const cy = h / 2;
            const margin = 60; 
            const radius = Math.min(w, h) / 2 - margin;
            return { w, h, cx, cy, radius };
        }

        function draw() {
            const { w, h, cx, cy, radius } = getCanvasMetrics();
            ctx.clearRect(0, 0, w, h);

            const vertices = [];
            for (let i = 0; i < currentSides; i++) {
                const theta = rotationOffset + (i * 2 * Math.PI / currentSides);
                vertices.push({
                    x: cx + radius * Math.cos(theta),
                    y: cy + radius * Math.sin(theta),
                    angle: theta
                });
            }

            // 1. ç¹ªè£½å¤šé‚Šå½¢
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < vertices.length; i++) {
                ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            ctx.closePath();
            ctx.fillStyle = 'rgba(224, 242, 254, 0.4)'; 
            ctx.fill();
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#0284c7'; 
            ctx.lineJoin = 'round';
            ctx.stroke();

            // 2. ç¹ªè£½å¤–è§’
            drawExteriorAngles(vertices, cx, cy);
        }

        function drawExteriorAngles(vertices, cx, cy) {
            const extLen = 40; 
            const arcRadius = 20; 
            let textStep = 1;
            if (currentSides > 12) textStep = 2;
            if (currentSides > 24) textStep = 4;
            if (currentSides > 40) textStep = 8;

            vertices.forEach((curr, i) => {
                const prevIndex = (i - 1 + currentSides) % currentSides;
                const nextIndex = (i + 1) % currentSides;
                const prev = vertices[prevIndex];
                const next = vertices[nextIndex];

                const anglePrevToCurr = Math.atan2(curr.y - prev.y, curr.x - prev.x);
                const angleCurrToNext = Math.atan2(next.y - curr.y, next.x - curr.x);

                const currentExtLen = currentSides > 20 ? 25 : extLen;
                ctx.beginPath();
                ctx.setLineDash([3, 3]);
                ctx.lineWidth = 1.5;
                ctx.strokeStyle = '#f97316'; 
                ctx.moveTo(curr.x, curr.y);
                ctx.lineTo(
                    curr.x + currentExtLen * Math.cos(anglePrevToCurr),
                    curr.y + currentExtLen * Math.sin(anglePrevToCurr)
                );
                ctx.stroke();
                ctx.setLineDash([]); 

                ctx.beginPath();
                ctx.strokeStyle = '#ea580c';
                ctx.lineWidth = 1.5;
                ctx.arc(curr.x, curr.y, arcRadius, anglePrevToCurr, angleCurrToNext, false);
                ctx.stroke();

                if (i % textStep === 0) {
                    const v1x = Math.cos(anglePrevToCurr);
                    const v1y = Math.sin(anglePrevToCurr);
                    const v2x = Math.cos(angleCurrToNext);
                    const v2y = Math.sin(angleCurrToNext);
                    
                    const bisectorX = v1x + v2x;
                    const bisectorY = v1y + v2y;
                    const bisectorLen = Math.sqrt(bisectorX*bisectorX + bisectorY*bisectorY);
                    
                    const textDist = arcRadius + 15;
                    const textX = curr.x + (bisectorX / bisectorLen) * textDist;
                    const textY = curr.y + (bisectorY / bisectorLen) * textDist;

                    ctx.fillStyle = '#c2410c';
                    ctx.font = currentSides > 12 ? '10px Arial' : 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    let degreeText = Math.round(360 / currentSides);
                    if (360 % currentSides !== 0) degreeText = (360 / currentSides).toFixed(1);
                    ctx.fillText(degreeText + "Â°", textX, textY);
                }
            });
            
            ctx.beginPath();
            ctx.arc(cx, cy, 2, 0, Math.PI * 2);
            ctx.fillStyle = '#94a3b8';
            ctx.fill();
        }

        // --- å‹•ç•«é‚è¼¯ (Canvas 1) ---
        async function animateDrawing() {
            if (isAnimating) return; 
            isAnimating = true;

            const { w, h, cx, cy, radius } = getCanvasMetrics();
            const btn = document.getElementById('replayBtn');
            btn.classList.add('opacity-50', 'cursor-not-allowed');
            
            const vertices = [];
            for (let i = 0; i < currentSides; i++) {
                const theta = rotationOffset + (i * 2 * Math.PI / currentSides);
                vertices.push({
                    x: cx + radius * Math.cos(theta),
                    y: cy + radius * Math.sin(theta),
                    angle: theta
                });
            }

            ctx.clearRect(0, 0, w, h);
            drawTurtle(ctx, vertices[0].x, vertices[0].y, rotationOffset);
            const sleep = ms => new Promise(r => setTimeout(r, ms));
            let stepDelay = 600;
            if (currentSides > 6) stepDelay = 300;
            if (currentSides > 12) stepDelay = 100;

            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';

            for (let i = 0; i < currentSides; i++) {
                if (!isAnimating) break; 
                const nextIndex = (i + 1) % currentSides;
                const nextV = vertices[nextIndex];
                const currV = vertices[i];

                ctx.beginPath();
                ctx.moveTo(currV.x, currV.y);
                ctx.lineTo(nextV.x, nextV.y);
                ctx.lineWidth = 4;
                ctx.strokeStyle = '#0284c7';
                ctx.stroke();

                await sleep(stepDelay / 2);
                if (!isAnimating) break;

                const nextTheta = rotationOffset + ((i + 1) * 2 * Math.PI / currentSides);
                const tangentAngle = nextTheta + Math.PI/2; 
                
                ctx.clearRect(0, 0, w, h);
                ctx.beginPath();
                ctx.moveTo(vertices[0].x, vertices[0].y);
                for(let k=1; k<=i+1; k++) {
                    ctx.lineTo(vertices[k%currentSides].x, vertices[k%currentSides].y);
                }
                ctx.lineWidth = 4;
                ctx.strokeStyle = '#0284c7';
                ctx.stroke();

                drawSingleExterior(vertices, i);
                drawTurtle(ctx, nextV.x, nextV.y, tangentAngle);
                await sleep(stepDelay);
            }

            if (isAnimating) draw();
            isAnimating = false;
            btn.classList.remove('opacity-50', 'cursor-not-allowed');
        }

        function drawSingleExterior(vertices, i) {
            const currIndex = (i + 1) % currentSides;
            const curr = vertices[currIndex];
            const prev = vertices[i]; 
            const next = vertices[(currIndex + 1) % currentSides]; 

            const anglePrevToCurr = Math.atan2(curr.y - prev.y, curr.x - prev.x);
            const angleCurrToNext = Math.atan2(next.y - curr.y, next.x - curr.x);
            
            const extLen = 40;
            const arcRadius = 25;

            ctx.beginPath();
            ctx.setLineDash([3, 3]);
            ctx.strokeStyle = '#f97316'; 
            ctx.lineWidth = 2;
            ctx.moveTo(curr.x, curr.y);
            ctx.lineTo(
                curr.x + extLen * Math.cos(anglePrevToCurr),
                curr.y + extLen * Math.sin(anglePrevToCurr)
            );
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.beginPath();
            ctx.strokeStyle = '#ea580c';
            ctx.arc(curr.x, curr.y, arcRadius, anglePrevToCurr, angleCurrToNext, false);
            ctx.stroke();
            
            let degreeText = Math.round(360 / currentSides);
            if (360 % currentSides !== 0) degreeText = (360 / currentSides).toFixed(1);
            
            ctx.fillStyle = '#c2410c';
            ctx.font = 'bold 14px Arial';
            ctx.fillText(degreeText + "Â°", curr.x + 40, curr.y - 10);
        }

        function drawTurtle(context, x, y, angle) {
            context.save();
            context.translate(x, y);
            context.rotate(angle); 
            context.beginPath();
            context.moveTo(0, -10); 
            context.lineTo(8, 10);  
            context.lineTo(0, 5);   
            context.lineTo(-8, 10); 
            context.closePath();
            context.fillStyle = '#f59e0b'; 
            context.fill();
            context.strokeStyle = '#fff';
            context.lineWidth = 1;
            context.stroke();
            context.restore();
        }

        // --- èŠ±æœµå‹•ç•«é‚è¼¯ (Canvas 2) ---
        function drawStaticPatternPlaceholder() {
            // å¯ä»¥åœ¨é€™è£¡ç•«ä¸€å€‹æ·¡è‰²çš„éœæ…‹åœ–ï¼Œä½†ç›®å‰ç•™ç™½ä¹Ÿä¸éŒ¯
        }

        async function animatePattern() {
            if (isPatternAnimating) return;
            isPatternAnimating = true;

            const btn = document.getElementById('runPatternBtn');
            const originalText = btn.innerHTML;
            btn.innerHTML = '<span>â³ ç¹ªè£½ä¸­...</span>';
            btn.classList.add('opacity-75', 'cursor-wait');

            const w = pCanvas.width / dpr;
            const h = pCanvas.height / dpr;
            const cx = w / 2;
            const cy = h / 2;
            // èŠ±æœµåŠå¾‘è¦å°ä¸€é»ï¼Œå› ç‚ºæœƒæ—‹è½‰æ“´å¤§
            // è¨ˆç®—ï¼šåœ–å½¢æœ¬èº«åŠå¾‘ rï¼Œåœ–å½¢ä¸­å¿ƒé›¢å¤§ä¸­å¿ƒè·é›¢ R
            // é€™è£¡ç°¡åŒ–ï¼šæˆ‘å€‘ã€ŒåŸåœ°è½‰ã€ç„¶å¾Œç•«åœ–å½¢ã€‚
            // Scratch é‚è¼¯é€šå¸¸æ˜¯ï¼šç•«å®Œä¸€å€‹åœ–å½¢ -> å³è½‰ -> ç•«ä¸‹ä¸€å€‹ã€‚
            // é€™æ„å‘³è‘—åœ–å½¢æ˜¯ç¹è‘—ã€Œé ‚é»ã€æ—‹è½‰ã€‚
            // ç‚ºäº†ç•«å‡ºæ¼‚äº®çš„èŠ±æœµï¼Œæˆ‘å€‘å‡è¨­æ˜¯ç¹è‘—åœ–å½¢çš„ä¸€å€‹é ‚é»æ—‹è½‰ã€‚
            
            // è¨­å®šåœ–å½¢å¤§å°
            const shapeRadius = Math.min(w, h) / 4; 
            
            pCtx.clearRect(0, 0, w, h);

            const totalShapes = 12;
            const turnAngle = (2 * Math.PI) / totalShapes; // 30åº¦
            const sleep = ms => new Promise(r => setTimeout(r, ms));

            // æˆ‘å€‘æ¨¡æ“¬æµ·é¾œï¼šå¾ä¸­å¿ƒå‡ºç™¼
            // ä½†æ˜¯å¦‚æœç›´æ¥ç•«ï¼Œå¤šé‚Šå½¢æœƒåœ¨ä¸­å¿ƒåä¸€é‚Šã€‚
            // ç‚ºäº†è®“èŠ±æœµå±…ä¸­ï¼Œæˆ‘å€‘éœ€è¦å·§å¦™å®‰æ’èµ·å§‹é»ã€‚
            // Scratch ç•«æ³•ï¼šä¸‹ç­† -> (ç§»å‹•+è½‰å½)*n -> å³è½‰30åº¦
            // é€™æœƒå½¢æˆä¸€å€‹ç©ºå¿ƒç’°ç‹€èŠ±æœµã€‚
            
            // é¡è‰²é™£åˆ—
            const colors = ['#ef4444', '#f97316', '#f59e0b', '#84cc16', '#10b981', '#06b6d4', '#3b82f6', '#6366f1', '#8b5cf6', '#d946ef', '#f43f5e', '#fb7185'];

            for (let s = 0; s < totalShapes; s++) {
                if (!isPatternAnimating) break;

                // å„²å­˜ç•¶å‰ç‹€æ…‹ (æ—‹è½‰å¾Œ)
                pCtx.save();
                pCtx.translate(cx, cy);
                // æ—‹è½‰ s * 30åº¦
                // ç‚ºäº†è¦–è¦ºå¥½çœ‹ï¼Œæˆ‘å€‘ç¨å¾®åç§»èµ·å§‹è§’
                pCtx.rotate(s * turnAngle);
                
                // é–‹å§‹ç•«ä¸€å€‹å¤šé‚Šå½¢
                // å‡è¨­å¤šé‚Šå½¢çš„ä¸€å€‹é ‚é»åœ¨ (0,0) (å³å¤§åœ“å¿ƒ)
                // é€™æ¨£æœƒå½¢æˆå¾ä¸­å¿ƒå°„å‡ºçš„èŠ±ç“£
                
                const vertices = [];
                // è¨ˆç®—å¤šé‚Šå½¢é ‚é» (ç›¸å°æ–¼å¤šé‚Šå½¢è‡ªå·±çš„å±€éƒ¨åæ¨™)
                // å¦‚æœè¦è®“ä¸€å€‹é ‚é»åœ¨åŸé»ï¼Œæˆ‘å€‘éœ€è¦è¨ˆç®—åç§»
                // é€™è£¡ç°¡åŒ–ï¼šæˆ‘å€‘ç›´æ¥ç•«ä¸€å€‹æ­£å¤šé‚Šå½¢ï¼Œå…¶ã€Œä¸­å¿ƒã€åœ¨ y è»¸ä¸ŠæŸè™•ï¼Œè®“å®ƒçœ‹èµ·ä¾†åƒèŠ±ç“£
                // æˆ–è€…æ›´ç°¡å–®ï¼šæ¨¡ä»¿ Scratchï¼Œå¾åŸé»é–‹å§‹ç•«é‚Š
                
                // Scratch æ¨¡å¼æ¨¡æ“¬ï¼š
                // Move 50, Turn 360/n ... Repeat n
                // é€™æœƒç•«å‡ºä¸€å€‹å¤šé‚Šå½¢ï¼Œå…¶ä¸€é‚Šå¾åŸé»é–‹å§‹ã€‚
                
                const sideLength = shapeRadius * 0.8; // é‚Šé•·
                const polyExtAngle = (2 * Math.PI) / currentSides;
                
                let currentX = 0;
                let currentY = 0;
                let currentDir = -Math.PI / 2; // åˆå§‹æœä¸Š
                // ä¿®æ­£ï¼šç‚ºäº†è®“èŠ±ç“£å‘å¤–é–‹ï¼Œåˆå§‹æ–¹å‘ç¨å¾®èª¿æ•´
                // é€™æ¨£ç¬¬ä¸€æ¢é‚Šæœƒå¾€å¤–ç•«
                
                pCtx.beginPath();
                pCtx.moveTo(0, 0); // æ°¸é å¾å¤§åœ“å¿ƒé–‹å§‹
                
                // è¨­å®šé¡è‰²
                pCtx.strokeStyle = colors[s % colors.length];
                pCtx.lineWidth = 2;
                pCtx.fillStyle = `${colors[s % colors.length]}33`; // 20% opacity hex
                
                // é å…ˆè¨ˆç®—å¤šé‚Šå½¢è·¯å¾‘ (ç‚ºäº†å¡«è‰²)
                let tempX = 0;
                let tempY = 0;
                let tempDir = -Math.PI/2; 
                // èª¿æ•´åˆå§‹è§’åº¦è®“å¤šé‚Šå½¢"ç«™"åœ¨ä¸­å¿ƒ
                // å¦‚æœæ˜¯æ­£æ–¹å½¢ï¼Œå¾ä¸­å¿ƒå¾€ä¸Šç•«
                
                // ç¹ªè£½å¤šé‚Šå½¢è·¯å¾‘
                for(let k=0; k<currentSides; k++) {
                   // Move
                   tempX += sideLength * Math.cos(tempDir);
                   tempY += sideLength * Math.sin(tempDir);
                   pCtx.lineTo(tempX, tempY);
                   // Turn (Right in Scratch = +angle in Canvas if y is down? No, standard math)
                   // Scratch "Turn Right" changes direction clockwise.
                   // Canvas Angle: 0 is Right, PI/2 is Down.
                   // Current Dir is -PI/2 (Up).
                   // Turn Right 90 deg -> 0 (Right).
                   tempDir += polyExtAngle; 
                }
                pCtx.closePath();
                pCtx.stroke();
                pCtx.fill();
                
                pCtx.restore();

                // ç•«å®Œä¸€å€‹æš«åœä¸€ä¸‹
                await sleep(150);
            }

            btn.innerHTML = originalText;
            btn.classList.remove('opacity-75', 'cursor-wait');
            isPatternAnimating = false;
        }

        window.addEventListener('resize', () => {
            resizeCanvas();
            resizePatternCanvas();
        });
        
        resizeCanvas();
        resizePatternCanvas();
        handleShapeChange(3); 

    </script>
</body>
</html>